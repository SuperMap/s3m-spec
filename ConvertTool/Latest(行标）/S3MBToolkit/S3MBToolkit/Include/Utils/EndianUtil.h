/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

// Copyright 2019 Peter Dimov
//
// Distributed under the Boost Software License, Version 1.0.
// http://www.boost.org/LICENSE_1_0.txt

*/

// This header contains some selected pieces of boost/endian piled up together,
// hence the copyright statement above.
// Very few changes were applied to make the code autonomous, so that we
// would not have to bring in all the epic boost stuff.

#if !defined(ENDIANUTIL_H__B18125FA_2792_492A_BB7F_11B37ED7CAD1__INCLUDED_)
#define ENDIANUTIL_H__B18125FA_2792_492A_BB7F_11B37ED7CAD1__INCLUDED_

#pragma once

#include <type_traits>
#include <stdint.h>

#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__

# define BOOST_ENDIAN_NATIVE_ORDER_INITIALIZER little

#elif defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__

# define BOOST_ENDIAN_NATIVE_ORDER_INITIALIZER big

#elif defined(__BYTE_ORDER__) && defined(__ORDER_PDP_ENDIAN__) && __BYTE_ORDER__ == __ORDER_PDP_ENDIAN__

# error The Boost.Endian library does not support platforms with PDP endianness.

#elif defined(__LITTLE_ENDIAN__)

# define BOOST_ENDIAN_NATIVE_ORDER_INITIALIZER little

#elif defined(__BIG_ENDIAN__)

# define BOOST_ENDIAN_NATIVE_ORDER_INITIALIZER big

#elif defined(_MSC_VER) || defined(__i386__) || defined(__x86_64__)

# define BOOST_ENDIAN_NATIVE_ORDER_INITIALIZER little

#else

# error The Boost.Endian library could not determine the endianness of this platform.

#endif

namespace boost
{

namespace endian
{

enum class order
{
  big,
  little,
  native = BOOST_ENDIAN_NATIVE_ORDER_INITIALIZER
};

inline constexpr uint32_t endian_reverse_impl(uint32_t x) noexcept
{
  return (((x << 16 | x >> 16) << 8) & 0xff00ff00) | (((x << 16 | x >> 16) >> 8) & 0x00ff00ff);
}

inline constexpr uint64_t endian_reverse_impl(uint64_t x) noexcept
{
  return ((((x << 32 | x >> 32) & 0x0000FFFF0000FFFFULL) << 16 | ((x << 32 | x >> 32) & 0xFFFF0000FFFF0000ULL) >> 16) & 0x00FF00FF00FF00FFULL) << 8 | ((((x << 32 | x >> 32) & 0x0000FFFF0000FFFFULL) << 16 | ((x << 32 | x >> 32) & 0xFFFF0000FFFF0000ULL) >> 16) & 0xFF00FF00FF00FF00ULL) >> 8;
}

template <class EndianReversible>
inline void endian_reverse_inplace(EndianReversible& x) noexcept
{
  x = endian_reverse_impl(x);
}

namespace detail
{

template<class EndianReversibleInplace>
inline void conditional_reverse_inplace_impl(EndianReversibleInplace&, std::true_type) noexcept
{
}

template<class EndianReversibleInplace>
inline void conditional_reverse_inplace_impl(EndianReversibleInplace& x, std::false_type) noexcept
{
  endian_reverse_inplace(x);
}

}  // namespace detail

// generic conditional reverse in place
template <order From, order To, class EndianReversibleInplace>
inline void conditional_reverse_inplace(EndianReversibleInplace& x) noexcept
{
  //BOOST_STATIC_ASSERT(detail::is_endian_reversible_inplace<EndianReversibleInplace>::value);
  detail::conditional_reverse_inplace_impl(x, std::integral_constant<bool, From == To>());
}

template <class EndianReversibleInplace>
inline void native_to_little_inplace(EndianReversibleInplace& x) noexcept
{
  conditional_reverse_inplace<order::native, order::little>(x);
}

} // namespace endian

} // namespace boost

#endif